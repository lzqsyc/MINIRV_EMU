<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>函数使用文件库（Minirv_emu）</title>
<style>
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Microsoft YaHei", sans-serif; margin: 24px; }
h1 { margin-top: 0; }
input[type="text"] { width: 100%; padding: 10px; font-size: 16px; border: 1px solid #ccc; border-radius: 8px; }
.small { color: #666; font-size: 12px; }
.card { border: 1px solid #eee; border-radius: 12px; padding: 16px; margin: 12px 0; box-shadow: 0 1px 3px rgba(0,0,0,0.04); }
.tag { display:inline-block; padding:2px 8px; background:#f3f4f6; border-radius:999px; margin-right:6px; font-size:12px; }
.details { margin-top:10px; }
table { border-collapse: collapse; width: 100%; }
th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
.summary { display:flex; flex-wrap:wrap; gap:8px; }
.copy-btn { float:right; font-size:12px; cursor:pointer; background:#f1f5f9; border:1px solid #e2e8f0; padding:4px 8px; border-radius:8px; }
.hidden { display:none; }
</style>
</head>
<body>
  <h1>函数使用文件库 <span class="small">Minirv_emu</span></h1>
  <p>在下方搜索函数名（如 <code>printf</code>）或文件名（如 <code>minirv_execute.c</code>）。点击每张卡片可展开详细的原型、参数、项目用途和具体出现位置（文件+行号+片段）。</p>
  <input type="text" id="q" placeholder="搜索函数或文件…（支持部分匹配）" />
  <div id="container"></div>

<script>
const LIB = {"atoi": {"meta": {"prototype": "int atoi(const char *nptr);", "returns": "转换后的int。", "params": {"nptr": "数字串"}, "project_use": "（当前项目中未必出现，留作扩展。）"}, "counts": [], "occurrences": []}, "calloc": {"meta": {"prototype": "void *calloc(size_t nmemb, size_t size);", "returns": "成功返回指针，失败NULL。", "params": {"nmemb": "元素个数", "size": "单个大小"}, "project_use": "分配地址占用表并清零。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 1}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 1}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 46, "code": "int *addr_use = (int *)calloc(addr_count,sizeof(int));"}, {"file": "hex_objdump.c", "line": 42, "code": "return 1;"}, {"file": "hex_simple.c", "line": 35, "code": "return 1;"}]}, "exit": {"meta": {"prototype": "void exit(int status);", "returns": "不返回，终止进程。", "params": {"status": "退出码"}, "project_use": "致命错误（如内存申请失败）时立即退出。"}, "counts": [{"file": "minirv_cpu.c", "path": "/mnt/data/minirv_cpu.c", "count": 1}], "occurrences": [{"file": "minirv_cpu.c", "line": 9, "code": "exit(1);"}]}, "fclose": {"meta": {"prototype": "int fclose(FILE *stream);", "returns": "成功0，失败EOF。", "params": {"stream": "文件指针"}, "project_use": "读取/解析完成后的资源释放。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 3}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 1}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 30, "code": "fclose(f);"}, {"file": "hex_check.c", "line": 49, "code": "fclose (f);"}, {"file": "hex_check.c", "line": 90, "code": "fclose(f);"}, {"file": "hex_objdump.c", "line": 102, "code": "if ((*line_count) % 1000 ==0){"}, {"file": "hex_simple.c", "line": 69, "code": "(*inst_count)++;"}]}, "fgets": {"meta": {"prototype": "char *fgets(char *s, int size, FILE *stream);", "returns": "成功返回s，EOF或出错返回NULL。", "params": {"s": "缓冲区", "size": "最大读取长度（含终止符）", "stream": "输入流"}, "project_use": "读取一整行命令或文本行，便于逐行解析。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 1}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 1}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}, {"file": "minirv_mode.c", "path": "/mnt/data/minirv_mode.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 57, "code": "while (fgets(line,sizeof(line),f))"}, {"file": "hex_objdump.c", "line": 47, "code": "int address_count = cpu->mem_size/4;"}, {"file": "hex_simple.c", "line": 40, "code": "uint32_t instruction;"}, {"file": "minirv_mode.c", "line": 15, "code": "if (fgets(command,sizeof(command),stdin)==NULL){"}]}, "fopen": {"meta": {"prototype": "FILE *fopen(const char *path, const char *mode);", "returns": "成功返回FILE*，失败返回NULL。", "params": {"path": "文件路径", "mode": "打开模式，如\"r\""}, "project_use": "在多条搜索路径中打开 hex/objdump/simple 文件以读取。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 2}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 1}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 26, "code": "FILE *f = fopen(filepath,\"r\");"}, {"file": "hex_check.c", "line": 41, "code": "FILE *f = fopen(filepath,\"r\");"}, {"file": "hex_objdump.c", "line": 45, "code": "void load_objdump(const char *filepath,CPU_state *cpu,int *line_count,int *inst_count,int *error_count){"}, {"file": "hex_simple.c", "line": 38, "code": "void load_simple(const char *filepath, CPU_state *cpu,int *line_count,int *inst_count,int *error_count){"}]}, "fprintf": {"meta": {"prototype": "int fprintf(FILE *stream, const char *format, ...);", "returns": "成功输出字符数；失败负值。", "params": {"stream": "目标流", "format": "格式", "...": "可变参数"}, "project_use": "（当前项目中未必出现，保留占位。）"}, "counts": [], "occurrences": []}, "free": {"meta": {"prototype": "void free(void *ptr);", "returns": "无返回值。", "params": {"ptr": "先前分配的指针"}, "project_use": "释放模拟内存/占用表等。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 1}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 1}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}, {"file": "minirv_cpu.c", "path": "/mnt/data/minirv_cpu.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 91, "code": "free(addr_use);"}, {"file": "hex_objdump.c", "line": 103, "code": "printf(\"已处理 %d 行，加载 %d 条指令\\n\", *line_count, *inst_count);"}, {"file": "hex_simple.c", "line": 70, "code": "}"}, {"file": "minirv_cpu.c", "line": 21, "code": "free(cpu->memory);"}]}, "fseek": {"meta": {"prototype": "int fseek(FILE *stream, long offset, int whence);", "returns": "成功0，失败非0。", "params": {"stream": "文件指针", "offset": "偏移量", "whence": "SEEK_SET/SEEK_CUR/SEEK_END"}, "project_use": "必要时调整读指针（跳过头部/回到开头）。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 2}], "occurrences": [{"file": "hex_check.c", "line": 70, "code": "fseek (f,0,SEEK_SET);"}, {"file": "hex_check.c", "line": 80, "code": "fseek (f,0,SEEK_SET);"}]}, "getchar": {"meta": {"prototype": "int getchar(void);", "returns": "读到的字符（转换为int）；EOF返回EOF。", "params": {}, "project_use": "清理输入缓冲区的残留换行/杂字符。"}, "counts": [{"file": "hex_load.c", "path": "/mnt/data/hex_load.c", "count": 5}, {"file": "minirv_main.c", "path": "/mnt/data/minirv_main.c", "count": 2}], "occurrences": [{"file": "hex_load.c", "line": 17, "code": "while ((c = getchar()) != '\\n' && c != EOF);    //赋值低于比较运算法"}, {"file": "hex_load.c", "line": 41, "code": "while ((c = getchar()) != '\\n' && c != EOF);"}, {"file": "hex_load.c", "line": 43, "code": "while ((c = getchar()) != '\\n' && c != EOF);"}, {"file": "minirv_main.c", "line": 17, "code": "while (getchar() !='\\n');"}, {"file": "minirv_main.c", "line": 20, "code": "while (getchar()!='\\n');"}]}, "isspace": {"meta": {"prototype": "int isspace(int c);", "returns": "空白为非0，否则0。", "params": {"c": "字符（unsigned char 或 EOF）"}, "project_use": "裁剪/跳过空白，清洗文本。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 2}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 2}], "occurrences": [{"file": "hex_check.c", "line": 105, "code": "while(isspace((unsigned char)*start)) start++;"}, {"file": "hex_check.c", "line": 112, "code": "while(isspace((unsigned char)*end)) {"}, {"file": "hex_simple.c", "line": 7, "code": "if( !isxdigit((unsigned char)*p) && !isspace((unsigned char)*p) ){"}, {"file": "hex_simple.c", "line": 19, "code": "*/"}]}, "isxdigit": {"meta": {"prototype": "int isxdigit(int c);", "returns": "是十六进制字符为非0。", "params": {"c": "字符（unsigned char 或 EOF）"}, "project_use": "校验简单格式行仅含十六进制字符。"}, "counts": [{"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}], "occurrences": [{"file": "hex_simple.c", "line": 7, "code": "if( !isxdigit((unsigned char)*p) && !isspace((unsigned char)*p) ){"}]}, "malloc": {"meta": {"prototype": "void *malloc(size_t size);", "returns": "成功返回指针，失败NULL。", "params": {"size": "字节数"}, "project_use": "为模拟内存分配缓冲区。"}, "counts": [{"file": "minirv_cpu.c", "path": "/mnt/data/minirv_cpu.c", "count": 1}], "occurrences": [{"file": "minirv_cpu.c", "line": 5, "code": "cpu->memory = (uint8_t*)malloc(cpu->mem_size); //  将内存大小转化为字节数组，并且由字节指针寻址"}]}, "memcpy": {"meta": {"prototype": "void *memcpy(void *dest, const void *src, size_t n);", "returns": "dest。", "params": {"dest": "目标", "src": "源", "n": "字节数"}, "project_use": "将解析到的字节按小端组合成32位指令等。"}, "counts": [], "occurrences": []}, "memmove": {"meta": {"prototype": "void *memmove(void *dest, const void *src, size_t n);", "returns": "dest。", "params": {"dest": "目标", "src": "源", "n": "字节数"}, "project_use": "原地去除行首空白（支持重叠区域）。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 107, "code": "memmove(line,start,strlen(start)+1);"}]}, "memset": {"meta": {"prototype": "void *memset(void *s, int c, size_t n);", "returns": "s。", "params": {"s": "指针", "c": "字节值", "n": "填充长度"}, "project_use": "初始化内存与寄存器数组为0。"}, "counts": [{"file": "minirv_cpu.c", "path": "/mnt/data/minirv_cpu.c", "count": 2}], "occurrences": [{"file": "minirv_cpu.c", "line": 11, "code": "memset(cpu->memory,0,cpu->mem_size);"}, {"file": "minirv_cpu.c", "line": 12, "code": "memset(cpu->GPR,0,sizeof(cpu->GPR));"}]}, "printf": {"meta": {"prototype": "int printf(const char *format, ...);", "returns": "成功输出的字符数；失败返回负值。", "params": {"format": "格式化字符串", "...": "可变参数，对应各占位符"}, "project_use": "命令行交互与调试打印：显示PC、指令语义、寄存器/内存状态、错误信息等。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 12}, {"file": "hex_execute.c", "path": "/mnt/data/hex_execute.c", "count": 10}, {"file": "hex_load.c", "path": "/mnt/data/hex_load.c", "count": 20}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 7}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 7}, {"file": "minirv_cpu.c", "path": "/mnt/data/minirv_cpu.c", "count": 4}, {"file": "minirv_execute.c", "path": "/mnt/data/minirv_execute.c", "count": 15}, {"file": "minirv_gpr.c", "path": "/mnt/data/minirv_gpr.c", "count": 7}, {"file": "minirv_main.c", "path": "/mnt/data/minirv_main.c", "count": 10}, {"file": "minirv_mem.c", "path": "/mnt/data/minirv_mem.c", "count": 6}, {"file": "minirv_mode.c", "path": "/mnt/data/minirv_mode.c", "count": 22}], "occurrences": [{"file": "hex_check.c", "line": 13, "code": "printf(\"\\n正在搜索文件: %s\\n\", filename);"}, {"file": "hex_check.c", "line": 14, "code": "printf(\"搜索路径:\\n\");"}, {"file": "hex_check.c", "line": 24, "code": "printf(\"  尝试: %s -> \", possible_paths[i]);"}, {"file": "hex_execute.c", "line": 8, "code": "printf(\"输入文件名不能为空！\\n\");"}, {"file": "hex_execute.c", "line": 14, "code": "printf(\"错误：无法找到hex文件 %s \\n\",filepath);"}, {"file": "hex_execute.c", "line": 17, "code": "printf(\"找到文件：%s\\n\",filepath);"}, {"file": "hex_load.c", "line": 4, "code": "printf(\"\\n ===Hex文件加载模式 ===\\n\");"}, {"file": "hex_load.c", "line": 5, "code": "printf(\"支持的文件格式：\\n\");"}, {"file": "hex_load.c", "line": 6, "code": "printf(\"1. 简单格式：每行32位十六进制指令\\n\");"}, {"file": "hex_objdump.c", "line": 60, "code": "if (objdump_check(line,&address,instructions,&count)){"}, {"file": "hex_objdump.c", "line": 79, "code": "}"}, {"file": "hex_objdump.c", "line": 89, "code": "}"}, {"file": "hex_simple.c", "line": 44, "code": "if (address_used == NULL) return ;"}, {"file": "hex_simple.c", "line": 48, "code": "while (fgets(line, sizeof(line), f)){"}, {"file": "hex_simple.c", "line": 56, "code": "printf(\"警告: 第%d行 - 地址 0x%08x 已使用，跳过写入\\n\", *line_count, load_addr);"}, {"file": "minirv_cpu.c", "line": 8, "code": "printf(\"cpu模拟内存分配失败\");"}, {"file": "minirv_cpu.c", "line": 24, "code": "printf(\"cpu执行模拟结束！内存已释放！\");"}, {"file": "minirv_cpu.c", "line": 38, "code": "printf(\"指令越界！pc=0x%08x,inst=0x%08x\\n\",cpu->pc,cpu_inst);"}, {"file": "minirv_execute.c", "line": 4, "code": "printf(\"当前pc=0x%08x, Inst=0x%08x\\n\",cpu->pc,mem_read(cpu,cpu->pc));"}, {"file": "minirv_execute.c", "line": 16, "code": "printf(\"未知执行指令！funct3=0x%02x\",inst.funct3);"}, {"file": "minirv_execute.c", "line": 30, "code": "printf(\"未知执行指令！funct3=0x%02x\",inst.funct3);"}, {"file": "minirv_gpr.c", "line": 13, "code": "printf(\"输入读取寄存器无效！pc=0x%08x, reg=x%d\\n\",cpu->pc,reg);"}, {"file": "minirv_gpr.c", "line": 23, "code": "printf(\"输入读取寄存器无效！pc=0x%08x, reg=x%d\\n\",cpu->pc,reg);"}, {"file": "minirv_gpr.c", "line": 27, "code": "printf(\"寄存器x0不能写入！\\n\");"}, {"file": "minirv_main.c", "line": 3, "code": "printf(\"=== MiniRV RISC-V 模拟器启动 ===\\n\");"}, {"file": "minirv_main.c", "line": 8, "code": "printf(\"\\n=== 主菜单 ===\\n\");"}, {"file": "minirv_main.c", "line": 9, "code": "printf(\"1. 指令功能测试模式\\n\");"}, {"file": "minirv_mem.c", "line": 7, "code": "printf(\"字输入读取地址对齐失败！ pc=0x%08x\\n\",addr);"}, {"file": "minirv_mem.c", "line": 10, "code": "printf(\"字内存读取地址越界！pc=0x%08x\\n\",addr);"}, {"file": "minirv_mem.c", "line": 20, "code": "printf(\"字输入读写地址对齐失败！ pc=0x%08x\\n\",addr);"}, {"file": "minirv_mode.c", "line": 6, "code": "printf(\"\\n=== 进入单步调试模式 ===\\n\");"}, {"file": "minirv_mode.c", "line": 7, "code": "printf(\"命令: s(单步) r(运行) d(寄存器) m(内存) q(退出)\\n\");"}, {"file": "minirv_mode.c", "line": 13, "code": "printf(\"\\n[Inst=%d,pc=0x%08x] > : \",step_count,cpu->pc);"}]}, "putchar": {"meta": {"prototype": "int putchar(int c);", "returns": "写入字符或EOF。", "params": {"c": "字符"}, "project_use": "（当前项目中未必出现，保留占位。）"}, "counts": [], "occurrences": []}, "puts": {"meta": {"prototype": "int puts(const char *s);", "returns": "成功非负，失败EOF。", "params": {"s": "字符串"}, "project_use": "（当前项目中未必出现，保留占位。）"}, "counts": [], "occurrences": []}, "realloc": {"meta": {"prototype": "void *realloc(void *ptr, size_t size);", "returns": "新指针或NULL。", "params": {"ptr": "原指针", "size": "新大小"}, "project_use": "（当前项目中未必出现，留作扩展。）"}, "counts": [], "occurrences": []}, "scanf": {"meta": {"prototype": "int scanf(const char *format, ...);", "returns": "成功匹配并赋值的项数。", "params": {"format": "格式化字符串", "...": "指向目标变量的指针"}, "project_use": "主菜单/简单问答输入，和printf组成简易TUI。"}, "counts": [{"file": "hex_load.c", "path": "/mnt/data/hex_load.c", "count": 3}, {"file": "minirv_main.c", "path": "/mnt/data/minirv_main.c", "count": 1}], "occurrences": [{"file": "hex_load.c", "line": 11, "code": "if (scanf(\"%s\",filename) !=1)"}, {"file": "hex_load.c", "line": 38, "code": "if (scanf(\"%d\",&execute_mode) !=1)"}, {"file": "hex_load.c", "line": 67, "code": "if (scanf(\"%s\",retry) == 1 && strcmp(retry,\"yes\") == 0)"}, {"file": "minirv_main.c", "line": 14, "code": "if (scanf(\"%d\",&mode) !=1)"}]}, "sscanf": {"meta": {"prototype": "int sscanf(const char *str, const char *format, ...);", "returns": "成功匹配并赋值的项数。", "params": {"str": "源字符串", "format": "格式", "...": "输出变量指针"}, "project_use": "从命令文本解析十六进制地址、数字参数。"}, "counts": [{"file": "minirv_mode.c", "path": "/mnt/data/minirv_mode.c", "count": 1}], "occurrences": [{"file": "minirv_mode.c", "line": 42, "code": "if (sscanf(command+2,\"%x\",&addr)==1)      // sscanf(addr*,\"mode\",*addr)第一个是读取地址，第二个写入地址"}]}, "strchr": {"meta": {"prototype": "char *strchr(const char *s, int c);", "returns": "首个匹配位置或NULL。", "params": {"s": "字符串", "c": "字符"}, "project_use": "objdump 行中定位冒号分隔的地址字段。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 2}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 17, "code": "if (strchr(possible_paths[i],'%') != NULL)"}, {"file": "hex_check.c", "line": 99, "code": "char *comment = strchr(line,'#');"}, {"file": "hex_objdump.c", "line": 5, "code": "char *colon = strchr(line,':');"}]}, "strcmp": {"meta": {"prototype": "int strcmp(const char *s1, const char *s2);", "returns": "相等0；小于/大于返回负/正。", "params": {"s1": "字符串1", "s2": "字符串2"}, "project_use": "命令字精确匹配或简单回答判断。"}, "counts": [{"file": "hex_load.c", "path": "/mnt/data/hex_load.c", "count": 3}, {"file": "minirv_mode.c", "path": "/mnt/data/minirv_mode.c", "count": 4}], "occurrences": [{"file": "hex_load.c", "line": 19, "code": "if (strcmp(filename,\"q\") ==0 || strcmp(filename,\"Q\") == 0)"}, {"file": "hex_load.c", "line": 67, "code": "if (scanf(\"%s\",retry) == 1 && strcmp(retry,\"yes\") == 0)"}, {"file": "minirv_mode.c", "line": 20, "code": "if (strcmp(command, \"s\") == 0){"}, {"file": "minirv_mode.c", "line": 33, "code": "} else if (strcmp(command,\"r\")==0){"}, {"file": "minirv_mode.c", "line": 36, "code": "} else if (strcmp(command,\"d\")==0)"}]}, "strcpy": {"meta": {"prototype": "char *strcpy(char *dest, const char *src);", "returns": "dest。", "params": {"dest": "目标", "src": "源"}, "project_use": "（当前项目中未必出现，保留占位。）"}, "counts": [], "occurrences": []}, "strlen": {"meta": {"prototype": "size_t strlen(const char *s);", "returns": "字符串长度（不含\\0）。", "params": {"s": "C字符串"}, "project_use": "校验空行/短行，配合文本清洗与解析。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 1}, {"file": "hex_execute.c", "path": "/mnt/data/hex_execute.c", "count": 1}, {"file": "minirv_mode.c", "path": "/mnt/data/minirv_mode.c", "count": 1}], "occurrences": [{"file": "hex_check.c", "line": 107, "code": "memmove(line,start,strlen(start)+1);"}, {"file": "hex_execute.c", "line": 6, "code": "if (filename == NULL || strlen(filename) == 0)"}, {"file": "minirv_mode.c", "line": 58, "code": "}else if (strlen(command)>0){"}]}, "strncmp": {"meta": {"prototype": "int strncmp(const char *s1, const char *s2, size_t n);", "returns": "比较前n个字符的结果。", "params": {"s1": "字符串1", "s2": "字符串2", "n": "比较长度"}, "project_use": "命令前缀判断（如\"m \"开头）。"}, "counts": [{"file": "minirv_mode.c", "path": "/mnt/data/minirv_mode.c", "count": 1}], "occurrences": [{"file": "minirv_mode.c", "line": 39, "code": "} else if (strncmp(command,\"m \",2)==0)        // 从数组其实地址开始读取num个前缀字符"}]}, "strncpy": {"meta": {"prototype": "char *strncpy(char *dest, const char *src, size_t n);", "returns": "dest。", "params": {"dest": "目标缓冲", "src": "源", "n": "最大拷贝数"}, "project_use": "安全抽取地址子串以便转换。"}, "counts": [{"file": "hex_check.c", "path": "/mnt/data/hex_check.c", "count": 1}, {"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 2}], "occurrences": [{"file": "hex_check.c", "line": 21, "code": "strncpy(filepath,possible_paths[i],path_size);"}, {"file": "hex_objdump.c", "line": 9, "code": "strncpy(line_addr,line,colon-line);"}, {"file": "hex_objdump.c", "line": 19, "code": "strncpy(data_copy,data_start,sizeof(data_copy)-1);"}]}, "strtol": {"meta": {"prototype": "long strtol(const char *nptr, char **endptr, int base);", "returns": "转换后的长整型；失败返回0。", "params": {"nptr": "数字串", "endptr": "停止位置输出", "base": "进制"}, "project_use": "（当前项目中未必出现，留作扩展。）"}, "counts": [], "occurrences": []}, "strtoul": {"meta": {"prototype": "unsigned long strtoul(const char *nptr, char **endptr, int base);", "returns": "转换后的无符号长整型；失败返回0。", "params": {"nptr": "数字串", "endptr": "停止位置输出", "base": "进制"}, "project_use": "将地址/字节token从16进制文本转成数值。"}, "counts": [{"file": "hex_objdump.c", "path": "/mnt/data/hex_objdump.c", "count": 2}, {"file": "hex_simple.c", "path": "/mnt/data/hex_simple.c", "count": 1}], "occurrences": [{"file": "hex_objdump.c", "line": 13, "code": "uint32_t word_addr = (uint32_t)strtoul(line_addr,&endptr,16);"}, {"file": "hex_objdump.c", "line": 27, "code": "*/"}, {"file": "hex_simple.c", "line": 13, "code": "while(*p){"}]}};

function render(list) {
  const root = document.getElementById('container');
  root.innerHTML = '';
  list.forEach(([fname, entry]) => {
    const total = (entry.counts || []).reduce((a,b)=>a + (b.count||0), 0);
    const card = document.createElement('div');
    card.className = 'card';
    const title = document.createElement('div');
    title.innerHTML = '<strong>'+fname+'</strong> ' + '<span class="tag">总计：'+ total +'</span>';
    card.appendChild(title);

    const meta = entry.meta || {}
    const details = document.createElement('div');
    details.className = 'details';

    const proto = meta.prototype ? '<div><strong>原型：</strong><code>'+meta.prototype+'</code></div>' : '';
    const returns = meta.returns ? '<div><strong>返回值：</strong>'+meta.returns+'</div>' : '';
    let paramsHTML = '';
    if (meta.params) {
      paramsHTML = '<div><strong>参数：</strong>' + Object.entries(meta.params).map(([k,v])=>'<span class="tag"><code>'+k+'</code>：'+v+'</span>').join(' ') + '</div>';
    }
    const useHTML = meta.project_use ? '<div><strong>本项目用途：</strong>'+meta.project_use+'</div>' : '';

    let countsHTML = '';
    if (entry.counts && entry.counts.length) {
      countsHTML = '<h4>各文件使用次数</h4><table><thead><tr><th>文件</th><th>次数</th></tr></thead><tbody>' +
        entry.counts.map(c=>'<tr><td>'+ (c.file||'') +'</td><td>'+ (c.count||0) +'</td></tr>').join('') +
        '</tbody></table>';
    }

    let occHTML = '';
    if (entry.occurrences && entry.occurrences.length) {
      occHTML = '<h4>示例出现位置（最多3条/文件）</h4><table><thead><tr><th>文件</th><th>行号</th><th>片段</th></tr></thead><tbody>' +
        entry.occurrences.map(o=>'<tr><td>'+ (o.file||'') +'</td><td>'+ (o.line||'') +'</td><td><code>'+ String(o.code||'').replace(/</g,'&lt;') +'</code></td></tr>').join('') +
        '</tbody></table>';
    }

    details.innerHTML = proto + returns + paramsHTML + useHTML + countsHTML + occHTML;
    details.classList.add('hidden');
    card.appendChild(details);

    card.addEventListener('click', () => {
      details.classList.toggle('hidden');
    });

    root.appendChild(card);
  });
}

function filter(q) {
  q = (q||'').trim().toLowerCase();
  let arr = Object.entries(LIB);
  if (q) {
    arr = arr.filter(([fname, entry]) => {
      if (fname.toLowerCase().includes(q)) return true;
      const inCounts = (entry.counts||[]).some(c => String(c.file||'').toLowerCase().includes(q));
      const inOcc = (entry.occurrences||[]).some(o => String(o.file||'').toLowerCase().includes(q) || String(o.code||'').toLowerCase().includes(q));
      return inCounts || inOcc;
    });
  }
  arr.sort((a,b)=>{
    const at = (a[1].counts||[]).reduce((x,y)=>x+(y.count||0),0);
    const bt = (b[1].counts||[]).reduce((x,y)=>x+(y.count||0),0);
    return bt - at || a[0].localeCompare(b[0]);
  });
  render(arr);
}

document.getElementById('q').addEventListener('input', (e)=> filter(e.target.value));
filter('');
</script>
</body>
</html>
