# Hex 文件加载与地址转换逻辑总结

## 1. 核心难点：数据格式的特殊性

我们所使用的 Hex 文件采用了一种特殊的**"指令索引 (Word Index)"**寻址方式，而非标准的字节寻址。这是理解代码中地址计算逻辑的前提。

### 文件样本格式

```text
行1: 00000: 00000413 ... (共8个指令)
行2: 00008: 00001437 ... (共8个指令)
```

### 格式解析

*   **冒号前的数字**：代表**"这是全文件的第几条指令"** (流水号/索引号)。
    *   `00000`：第 0 条指令开始。
    *   `00008`：第 8 条指令开始（因为上一行写了 0~7 号指令）。
*   **冒号后的数据**：具体的 32 位指令代码，每行 8 个。

## 2. 这里的“按字”处理逻辑与 *4 的由来

在函数 `objdump_check` 中，有一行关键代码：

```c
*addr = word_addr * 4;
```

### 逻辑推导

1.  **输入单位**：文件给出的 `word_addr` 是指令个数（例如 8）。
2.  **目标单位**：CPU 内存读写使用的是字节地址 (Byte Address)。
3.  **转换关系**：1 条 32 位指令占用 **4 字节**。
4.  **计算结果**：
    *   第 1 行 (0) -> `0 * 4 = 0x00`
    *   第 2 行 (8) -> `8 * 4 = 32 (0x20)`

### 结论

这一步转换保证了内存写入是严丝合缝、连续不断的。

*   第 1 行填充 `0x00 ~ 0x1F` (32字节)。
*   第 2 行紧接着从 `0x20` 开始填充。
    中间没有未使用的空间，没有地址浪费。

## 3. 最终物理写入地址计算公式 (核心)

在 `load_objdump` 函数的加载循环中，最终写入 CPU 的物理地址是由三个维度叠加而成的：

```c
行基准起始地址：lines_addr = Instr_index * 4  (按指令字节写入，每指令4字节32位；每行起始指令索引乘4得到行基准地址)
指令内存写地址：mem_write(cpu, lines_addr + i*4 + LOAD_START, instructions[i]);
```

我们可以将其总结为以下公式：

$$Target\_Addr = \underbrace{lines\_addr}_{① 行基准地址} + \underbrace{(i \times 4)}_{②行内i指令偏移} + \underbrace{LOAD\_START}_{③ 全局基地址}$$

### 公式拆解

1.  **① 行基准 (address)**
    *   **来源**：由 `objdump_check` 解析冒号前的索引并 `*4` 得到。
    *   **含义**：这一行 8 个指令在内存中的发起地址门牌号（如 `0x00`, `0x20`），即是：address = Instr_index * 4。
2.  **② 行内偏移 (i * 4)**
    *   **来源**：`for` 循环变量 `i` (0 到 7)。
    *   **含义**：当前指令是这一行的第几个？
    *   `i=0`(偏移0), `i=1`(偏移4) ... `i=7`(偏移28)。这确保了行内的指令也是按字节连续排列的。
3.  **③ 全局基地址 (LOAD_START)**
    *   **来源**：宏定义。
    *   **含义**：整个程序在物理内存中的搬迁基址。
    *   如果为 `0`，则从内存 `0` 地址开始写；如果为 `0x80000000`，则整体平移。

## 4. 检查与加载的逻辑架构关联

代码采用**"两次遍历"**的策略，通过复用 `objdump_check` 解析引擎来实现解耦。

### 阶段一：格式检查 (hex_format_check)

*   **动作**：读取前 10 行 -> `clean_format` -> `objdump_check`。
*   **目的**：**"只看不买"**。验证解析是否成功，返回值 1 或 0。
*   **数据流向**：解析出的 `addr` 和 `instructions` 存入临时变量后**被丢弃**，不涉及内存写入。

### 阶段二：正式加载 (load_objdump)

*   **动作**：重读全文件 -> `clean_format` -> `objdump_check`。
*   **目的**：**"照单全收"**。
*   **数据流向**：
    1.  解析出的 `address` 用于**查重** (检查 `address_used` 表)。
    2.  解析出的 `address` 和 `instructions` 代入上述最终公式，通过 `mem_write` 永久写入 CPU 内存。


#  内存冲突检测机制与 address_used 逻辑解析 (conflict-check.md)

## 1. 核心概念：影子内存 (Shadow Memory)

代码中定义的 `address_used` 数组并非 CPU 的真实存储空间，而是一个**“记账本”**（或称位图/影子内存）。它的存在是为了在加载过程中实时监控地址占用情况。

### 角色区分
*   **`cpu->mem` (真实内存)**：实际存放指令数据的仓库。
*   **`address_used` (标记数组)**：用于记录哪些“仓库货架”已经被占用的清单。

---

## 2. 数组粒度：按字 (Word) 映射

**结论：`address_used` 数组是按“字”（4字节）粒度进行映射的。**

### 代码证据分析
1.  **定义阶段**：
    ```c
    int address_count = cpu->mem_size / 4; // 总字节数除以4
    int *address_used = (int *)calloc(address_count, sizeof(int));
    ```
    *   **含义**：数组的元素个数只有内存总字节数的 1/4。说明**数组的一个格子对应内存的 4 个字节**。

2.  **使用阶段**：
    ```c
    if (address_used[inst_addr / 4]) ...
    ```
    *   **含义**：访问数组时，将字节地址 `inst_addr` 除以 4 转换为下标。
    *   **映射关系**：
        *   `address_used[0]` 监管 -> 内存地址 `0x00 - 0x03`
        *   `address_used[1]` 监管 -> 内存地址 `0x04 - 0x07`
        *   `address_used[2]` 监管 -> 内存地址 `0x08 - 0x0B`

---

## 3. 冲突检测的代码时序逻辑

如何在代码上验证地址是否已存入数据？依靠的是**时间先后顺序**的状态变化（从 0 变 1）。

### 逻辑流程演示

假设有两个指令先后都要写入地址 `0x20`（对应下标 8）。

#### 时间点 T1：处理第一行（首次写入）
1.  **预检阶段 (Check)**：
    *   检查 `address_used[8]`。
    *   此时数组是初始状态（全0），**检查通过**。
2.  **执行阶段 (Action)**：
    *   写入 CPU 内存。
    *   **标记占位**：执行 `address_used[8] = 1;`。
    *   *此时，影子内存第 8 格的状态变成了 1。*

#### 时间点 T2：处理第 N 行（冲突发生）
1.  **预检阶段 (Check)**：
    *   再次计算目标地址 `0x20` -> 下标 8。
    *   检查 `address_used[8]`。
    *   **发现状态为 1！**（这是 T1 时刻留下的痕迹）。
2.  **触发拦截**：
    *   设置 `any_used = 1`。
    *   执行 `continue` 跳过整行。
    *   **结果**：后续的 `mem_write` 根本不会执行，旧数据得以保留。

### 4. 总结

这套机制利用了一个简单的整数数组实现了**时序上的冲突记忆**：
*   **前人栽树**：先到的指令将对应位置标记为 1。
*   **后人撞墙**：后到的指令检查该位置时发现是 1，从而触发报警并避让。
*   **粒度对齐**：通过 `mem_size / 4` 和 `addr / 4`，完美契合了 32 位指令对齐的特性，节省了 75% 的辅助空间。

## 5. Bitmap (位图) 空间优化方案

### 1. 为什么需要优化？

#### 原方案痛点
*   **现状**：使用 `int` 数组 (`address_used`) 来标记地址占用。
*   **开销**：`int` 占用 32 位，但我们只存 0 或 1（仅需 1 位）。
*   **浪费率**：**97% (31/32)** 的内存空间被浪费。对于 1GB 的模拟内存，需要额外消耗 1GB 的辅助内存。

#### 优化目标
*   使用 **Bitmap (位图)** 技术，将空间占用缩减至原来的 **1/32**。
*   **效果**：1GB 的模拟内存，仅需 32MB 辅助内存。

### 2. 核心原理与数据结构

#### 映射逻辑
我们将 `address_used` 看作一个连续的二进制位流。

*   **数组粒度**：`uint32_t` (每个元素存 32 个标志位)。
*   **索引转换**：
    *   **桶索引 (Array Index)**：`idx / 32` -> 确定在数组的第几个 `int` 元素中。
    *   **位偏移 (Bit Offset)**：`idx % 32` -> 确定在该 `int` 内部的第几位。

#### 内存分配公式

```c
// (N + 31) / 32 是为了向上取整，确保能存下所有位
int bitmap_size = (address_count + 31) / 32;
uint32_t *address_used = (uint32_t *)calloc(bitmap_size, sizeof(uint32_t));
```

### 3. 关键 Helper 函数解析

#### 查位函数 (is_used)

```c
int is_used(uint32_t *map, int idx) {
    // 构造掩码：1U << (idx % 32)
    // 按位与 (&)：只有当 map 对应位也是 1 时，结果才非 0
    return map[idx / 32] & (1U << (idx % 32));
}
```

#### 置位函数 (set_used)

```c
void set_used(uint32_t *map, int idx) {
    // 按位或并赋值 (|=)：将掩码中的 1 强行写入 map，不影响其他位
    map[idx / 32] |= (1U << (idx % 32));
}
```
*注：`1U` 表示无符号整数 1，防止移位操作产生未定义行为。*

### 4. 实战演练：真实数据追踪

**场景假设**：处理 Hex 文件中的第 5 行数据。
**输入数据**：`00020: 00410233 ...` (冒号前 0x20 = 十进制 32)

#### 步骤追踪

*   **Step 1: 参数准备 (主函数)** 
    *   解析得到行基准索引：32。
    *   计算全局指令索引：`idx = 32 + 0 = 32`。

*   **Step 2: 查重 (调用 is_used)** 
    *   **传递参数**：map 指针, `idx = 32`。
    *   **内部定位**：
        *   **桶**：`32 / 32 = 1` -> 锁定 `map[1]`。
        *   **位**：`32 % 32 = 0` -> 锁定第 0 位。
    *   **逻辑判断**：假设 `map[1]` 当前为 0，结果 **安全**。

*   **Step 3: 标记 (调用 set_used)** 
    *   **内部定位**：锁定 `map[1]` 的第 0 位。
    *   **执行操作**：`map[1] |= (1U << 0)`。
    *   **结果**：Bitmap 成功记录了“第 32 号指令位置已被占用”。
